1. operator overloading formation: returnType operator operatorsymbol(formal parameter list) like:
   bool operator=(const int & a)
2. tips of overloading: 
   (1) don't change the priority of operator
   (2) don't change the associativity(结合律) of operator
   (3) can't use default parameter 
   (4) can't change the number of parameter that the operator need
   (5) can't overloading new operator like: "." ,".*", "::", "?:", "sizeof".
   (6) can't change the original rules of the operator.
   (7) operator can be overloading both in costumer define data type or inside-build data type.
3. "this" pointer: each object have "this" pointer, it is used when member function call object."*this" mean the object.
4. overloading function of "()","[]","->","=", should be member of class
5. if operator in the left of the overloading operator is in the different type of the class, that should be defined as friend function
6. if operator in the right of the overloading operator is in the same type of the class, that the left operator should be the class type.
7. other overloading functions can both be the member function and friend funtion.
8. overloading operator ">>" and "<<" in such form: 
   istream & operator>>(istream & isobject,  className & cobject)
   ostream & operator<<(ostream & osobject,  className & cobject)
   return type should be reference of iostream object for the convenience of "cout<<object1<<object2";
9. overloading operator "=" in such form:
   const className & className::operator=(const className & rightObject)
   {
      if (this != & rightObject)
      {}
      return *this;
   }
   return  const "*this" is for the convenience of "object1=object2=object3"
10. One of the reasons why human be so foolish is that we rely too much on the enviroment around.

